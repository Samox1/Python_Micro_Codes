# Plik proszę nazwać numerem swojego indeksu.
# 
# Zadanie 1:
# a) Stwórz funkcję "StopIfNot" przyjmującą nastęujące parametry: "Y", "X", "data", "type", "depth", "minobs", "overfit", "cf".
# b) Funkcja powinna sprawdzać czy nauka modelu jest możliwa do wykonania, tj:
#    - czy "data" jest ramką danych,
#    - czy wszystkie wymienione zmienne ("Y", "X") istnieją w "data",
#    - czy zmienna "Y" oraz zmienne "X" w tabeli "data" nie ma braków danych,
#    - czy "depth" oraz "minobs" są większe od 0,
#    - czy "type" przyjmuje watrtość "Gini", "Entropy", "SS",
#    - czy "overfit" przyjmuje watrtość "none" lub "prune",
#    - czy "cf" jest w przedziale (0,0.5],
#    - czy możliwe kombinacje parametrów mają sens, np. "type = SS" kiedy "Y" jest faktorem.
# c) W przypadku niespełniania któregoś z warunków, funkcja powinna wyświetlić w konsoli, czego dotyczy problem.
# d) Funkcja zwraca "TRUE", jeżeli nauka jest możliwa, w przeciwnym wypadku "FALSE". 
#
StopIfNot <- function( Y, X, data, type, depth, minobs, overfit, cf){

  
  if (is.data.frame(data)==FALSE){
    print("Typem parametru data nie jest ramka danych.")
    return(FALSE)}
  
  if(!all(c(X) %in% names(data))){
    print("Nie wszystkie zmienne X istnieja w data.")
    return(FALSE)}
  
  if(!all(c(Y) %in% names(data))){
    print("Zmienna Y nie istnieja w data.")
    return(FALSE)}
  
  if(any(is.na(data[,X]) == TRUE)){
    print("Występują braki danych w zmiennych X.")
    return(FALSE)}
  
  if(any(is.na(data[,Y]) == TRUE)){
    print("Występują braki danych w zmiennej Y.")
    return(FALSE)}
  
  if(depth  == 0 || depth  < 0){
    print("depth nie jest większe od 0")
    return(FALSE)}
  
  if(minobs  == 0 || minobs < 0){
    print("minobs nie jest większe od 0")
    return(FALSE)}
  
  if(type != 'Gini' && type != 'Entropy' && type != 'SS'){
    print("Niepoprawna wartosc typu!")
    return(FALSE)}
  
  if(overfit != 'none' && overfit != 'prune' ){
    print("Niepoprawna wartosc overfit!")
    return(FALSE)}
  
  if(cf <= 0 || cf > 0.5 ){
    print("Wartosc cf nie jest z przedziału (0, 0.5]!")
    return(FALSE)}
  
  if((is.factor(data[,Y])== TRUE && type=="SS") || 
  (is.numeric(data[,Y])==TRUE &&( type == "Entropy" || type == "Gini"))){
    print("Wybrana kombinacja parametrów type i data nie jest możliwa.")
    return(FALSE)}
  
  return(TRUE)
}


# 
# Zadanie 2:
# a) Stwórz funkcję "AssignInitialMeasures" przyjmującą nastęujące parametry: "tree", "Y", "data", "type", "depth".
# b) Funkcja powinna na podstawie parametrów wejściowych przypisywać do obiektu "tree" (czyli korzenia) wartości początkowe:
#    - "depth" = 0.
#    - w zależności od "type" wartość miary Gini, Entropy, SS dla calej populacji (bo to korzeń).

library(rpart)
library(data.tree)

#Prawdopodobieństwo 
Prob <- function( y_tar ){
  res <- unname( table( y_tar ) )
  res <- res / sum( res )
  return(res)
}

#Entropy

Entropy <- function( prob ){
  res <- prob * log2( prob )
  res[ prob == 0 ] <- 0
  res <- -sum( res )
  return( res )
}

#Gini

Gini <- function(prob){
  res <- prob^2
  res <- 1-sum(res)
  return(res)
}

#SS

SS <- function(y){
  res <- (y-mean(y))^2
  res <- sum(res)
  return(res)
}


AssignInitialMeasures <- function(tree, Y, data, type, depth){
  
  tree$Depth <- 0
  if(type=='Entropy'){
    tree$inf <- Entropy(Prob(data[,Y]))}
  else if(type == 'Gini'){
    tree$inf <- Gini(Prob(data[,Y]))
  }
  else{
    tree$inf <- SS(data[,Y])
  }
}

#   
# Zadanie 3:
# a) Stwórz funkcję "AssignInfo" przyjmującą nastęujące parametry: "tree", "Y", "X", "data", "type", "depth", "minobs", "overfit", "cf".
# b) Funkcja powinna na podstawie parametrów wejściowych przypisywać do obiektu "tree" (jako attrybuty obiektu) wartości owych parametrów.
#

AssignInfo <- function(tree,Y,X,data,type,depth, minobs, overfit, cf )
{
  tree$Y <- data[,Y]
  tree$X <- data[,X]
  tree$Data <- data
  tree$Type <- type
  tree$Depth <- depth
  tree$Minobs <- minobs
  tree$Overfit <- overfit
  tree$Cf <- cf 
}


#
# Zadanie 4:
# a) Stwórz funkcję "Tree" przyjmującą nastęujące parametry: "Y", "X", "data", "type", "depth", "minobs", "overfit", "cf".
# b) Jest to rozwinięcie funkcji ze slajdu nr 19. Funckja powinna po kolei wywoływać pozostałe funkcje:
#    - "StopIfNot", jeżeli zwracana wartość to "FALSE" to kończymy działanie całej funkcji (zwracamy obiekt niewidzialny),
#    - tworzenie obiektu "tree",
#    - "AssignInitialMeasures",
#    - "BuildTree",
#    - "PruneTree", na tę chwilę ta funkcja jest pusta PruneTree<-function(){},
#    - "AssignInfo".
# c) Funkcja powwina zwracać obiekt "tree".
#
# Zadanie 5:
# a) Dokonaj integracji opracowanej funkcji "FindBestSplit" z funkcjami "Tree" oraz "BuildTree". #nie trzeba robić 

BuildTree <- function(node, Y, X, data, depth, minobs, splitPoint){

  node$Count <- nrow( data )# za kazdym razem mamy dostep do wszystkich kolumn ale tylko do tych obserwacji kt potrzebujemy 
  node$Prob <- Prob( data[,Y] )
  tab <- table( data[,X] <= splitPoint )
  
  ifStop <- dim(tab) == 1 | node$Depth == depth | all( node$Prob %in% c(0,1) ) | any( tab < minobs )
  if( ifStop ){
    
    node$Leaf <- "*"
    return( node )
    
  }else{
    
    split_indx <- data[,X] <= splitPoint
    child_frame <- split( data, split_indx )
    
    name_l <- sprintf( "%s <= %s", X, splitPoint ) 
    child_l <- node$AddChild( name_l )
    child_l$value <- splitPoint
    child_l$Depth <- node$Depth + 1
    
    BuildTree( child_l, Y, X, child_frame[["TRUE"]], depth, minobs, splitPoint - 1 )
    
    
    name_r <- sprintf( "%s >  %s", X, splitPoint )
    child_r <- node$AddChild( name_r )
    child_r$value <- splitPoint
    child_r$Depth <- node$Depth + 1
    
    BuildTree( child_r, Y, X, child_frame[["FALSE"]], depth, minobs, splitPoint - 1 ) 
   
  }
  
}

Tree<- function(Y, X, data, type, depth, minobs, overfit,cf){
  if(StopIfNot(Y, X, data, type, depth, minobs, overfit,cf) == FALSE)
  {return(FALSE)}
  
  
  tree<- Node$new("Root")
  tree$Count <- nrow(data)
  splitPoint <- 10
  
  AssignInitialMeasures(tree, Y, data, type, depth)
  BuildTree( tree, Y, X, data, depth, minobs, splitPoint )  
  PruneTree <- function(){}
  AssignInfo(tree,Y,X,data,type,depth, minobs, overfit, cf )
 
  return( tree )
}
  





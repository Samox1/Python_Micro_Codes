# Integracja R z C++
install.packages("Rcpp")
library("Rcpp")

# Plik proszê nazwaæ numerem swojego indeksu.
# Plik powinien zawieraæ tylko definicjê funkcji z Zadania 1-4.

# Zadanie 1:
# a) Stwórz w C++ w³asn¹ implementacjê funkcji "matrix" przekszta³caj¹c¹ dowolny wektor na macierz o wymiarach "n x k".
# b) Funkcja przyjmuje nastêpuj¹ce parametry: wektor, liczba wierszy, 
#liczba kolumn, wskazanie czy dane wstawine 
#s¹ wierszami czy kolumnami, nazwy wymiarów.
# c) Funkcja powinna zwracaæ macierz.
# d) Funkcja bêdzie testowana na wektorach numerycznych i tekstowych.
# e) Nazwa funkcji to "matrixCpp".
# 

cppFunction({'NumericMatrix matrixCpp(NumericVector c, int n, int k, bool byrow )
{ 
  int p = 0;
  NumericMatrix macierz(n,k);
  if(byrow == 0)
  { 
    for(int i = 0;i < macierz.cols();i++ )
    {
      for(int j = 0;j < macierz.rows();j++)
      {
        macierz(j,i)=c[p];
        p++;
      }
    }
  }
  else
  {
    for(int i = 0; i < macierz.rows();i++)
      {
      for(int j = 0;j < macierz.cols();j++ )
        {macierz(i,j)=c[p];
         p++;
        }
      }
   }
 return(macierz);
}
'})

matrix(1:30,5,6,1)
matrix(1:30,5,6,1)

matrixCpp(1:30,5,6,1)
matrixCpp(1:30,5,6,0)


# Zadanie 2:
# a) Stwórz w C++ w³asn¹ implementacjê funkcji "cumsum" zwracaj¹c¹ sumy skumulowane.
# b) Funkcja przyjmuje nastêpuj¹ce parametry: wektor.
# c) Funkcja powinna zwracaæ wektor.
# d) Funkcja bêdzie testowana na wektorach numerycznych i tekstowych.
# e) Nazwa funkcji to "cumsumCpp".
#



cppFunction({'NumericVector cumsumCpp(NumericVector v )
{
  double m = 0;
  NumericVector wektor(v.size());
  for(int i=0; i < v.size(); i++)
  {
      m += v[i];
      wektor[i] = m;
  }
  return(wektor);
}
'})

cumsum(4:6)
cumsumCpp(4:6)


# Zadanie 3:
# a) Stwórz w C++ w³asn¹ implementacjê funkcji "rev"(zmiana kolejnoœci elementów) zwracaj¹c¹ wektor z elementami o odwróconej kolejnoœci.
# b) Funkcja przyjmuje nastêpuj¹ce parametry: wektor.
# c) Funkcja powinna zwracaæ wektor.
# d) Funkcja bêdzie testowana na wektorach numerycznych i tekstowych.
# e) Nazwa funkcji to "revCpp".
# 


cppFunction({'NumericVector revCpp(NumericVector w)
{
  int k = w.size();
  NumericVector wektor(k);
  for(int i = 0; i< k; i++)
    {
        wektor[i] = w[k-i-1];
    }
  return wektor;
}
'})


v = 1:10
rev(v)
revCpp(v)


# Zadanie 4:
# a) Stwórz w R w³asn¹ implementacjê oparatora "%*%" mno¿¹cego dwie macierze.
# b) Funkcja przyjmuje nastêpuj¹ce parametry: macierz1, macierz2.
# c) Funkcja powinna zwracaæ macierz, a je¿eli pomno¿enie macierzy nie jest mo¿liwe to komunikat "Opracja niemo¿liwa".
# d) Funkcja bêdzie testowana na macierzach o ró¿nych wymiarach.
# e) Nazwa funkcji to "matmultR".

matrix(1:30,5,6,1)
matrix(1:30,5,6,0)

A <- matrix(1:20,4,5)
B <- matrix(1:30,5,6)
A
B
f <- c(1,2,3,4,5,6,7,8)
g <- c(2,4,6,8,10,12,14,16,18,20)
D <- matrix(g,2,5)
E <- matrix(f,4,2)

matmultR = function(macierz1, macierz2)
{
  suma = 0 
  m = matrix(0,nrow(macierz1), ncol(macierz2))
  if(ncol(macierz1) = nrow(macierz2))
  {
    for(i in 1:row(m))
    {
      for(j in 1:col(m))
      {
        for(r in 1:col(macierz1))
        {
          suma = suma + macierz1[i,r]*macierz2[r,j]
          m[i,j]=suma
        }
        suma=0
      }
    }
    return(m)
  }
  else
  {
    print("Opracja niemo¿liwa")
  }
  
}

C <- E%*%D
C
matmultR(E,D)

# 
# Zadanie 5:
# czy moja funkcja dzia³a, czy jest wydajna ta funkcja do mnozenia macierzy, musi sprawdzaæ czy jest odpowiednia liczba wierszy i kolumn 
# a) Dokonaj przetestowania wydajnoœci opracowanych powy¿ej funkcji na losowo stworzonych wektorach.
# b) Porównaj wydajnoœæ w³asnych funkcji z funkcjami wbudowanymi.
# c) Dokonaj profilowania opracowanych funkcji w celu znalezienia ew. w¹skich garde³.


install.packages(profvis)
library(profvis)
library(ggplot2)

#############matrixCpp##############

l <- runif(30,1,100)

matrixCpp(l,5,6,1)
matrix(l,5,6,1)

library(microbenchmark)
microbenchmark(matrixCpp(l,5,6,1) ,matrix(l,5,6,1) )

profvis({matrixCpp(l,5,6,1)})


#############cumsumCpp##############

h <- c(runif(3,0,6))

cumsum(h)
cumsumCpp(h)

microbenchmark(cumsum(h), cumsumCpp(h) )


##############revCpp################

rev(h)
revCpp(h)

microbenchmark(rev(h), revCpp(h) )

##############matmultR##############

K <- matrix(runif(30,1,100),3,5,0)
M <- matrix(runif(30,1,100),5,3,0)

K%*%M
matmultR(K,M)

microbenchmark(K%*%M, matmultR(K,M) )

{
X_norm[,i] <- X[,i]
minOrg <- append(minOrg, NA)
maxOrg <- append(maxOrg, NA)
}
else
{
message(paste0("Wartosci niepoprawne w X, kolumna: ", name))
}
}
names(maxOrg) <- nazwa
names(minOrg) <- nazwa
attr(X_norm, 'minOrg') <- minOrg
attr(X_norm, 'maxOrg') <- maxOrg
attr(X_norm, 'minmaxNew') <- minmaxNew
knn <- list()
knn[["X"]] <- X_norm
knn[["y"]] <- y_tar
knn[["k"]] <- k
}
return(knn)
}
}
# - test 1
fac1 <- (sample(1:5, 10, replace = TRUE))
fac2 <- as.factor(sample(2:4, 10, replace = TRUE))
X1 <- cbind(fac1,fac2)
X1 <- as.matrix(X1)
X2 <- data.frame(fac1, fac2)
y_tar <- sample(0:1, 10, replace = TRUE)
k = 2
XminNew <- 0
XmaxNew <- 1
tabelka1 <- KNNtrain(X1, y_tar, k, XminNew, XmaxNew)
tabelka2 <- KNNtrain(X2, y_tar, k, XminNew, XmaxNew)
View(tabelka1)
tabelka1[["X"]][["fac1"]]
View(X1)
KNNtrain <- function(X, y_tar, k, XminNew, XmaxNew) {
if (any(is.na(X) == TRUE || is.na(y_tar) == TRUE)) {
stop("Niekompletne dane!")
}
else if(k <= 0)
{
stop("Za male k")
}
else if(XminNew == XmaxNew)
{
stop("Nowe granice sa takie same!")
}
else if((is.matrix(X) == FALSE & is.data.frame(X) == FALSE))
{
stop("Dane nie sa macierza lub ramka danych!")
}
else{
{
X <- as.data.frame(X)
X_norm <- data.frame(X)
X_norm[,] <- 0
# Sprawdzic KOD z Projekt_R_knn_Tree_SVM -> funkcje.R
nazwa <- vector()
minOrg <- vector()
maxOrg <- vector()
minmaxNew <- c(XminNew, XmaxNew)
column_names <- colnames(X)
for(i in 1:ncol(X))
{
message(typeof(X[,i]))
if (is.numeric(X[,i]) | is.double(X[,i]) | is.integer(X[,i]))
{
nazwa <- append(nazwa, i)
minOrg <- append(minOrg, min(X[,i]))
maxOrg <- append(maxOrg, max(X[,i]))
X_norm[,i] <- ((X[,i] - min(X[,i])) / (max(X[,i]) - min(X[,i]))) * (XmaxNew - XminNew) + XminNew
}
else if(is.factor(X[,i]) & is.ordered(X[,i]) | is.factor(X[,i]))
{
X_norm[,i] <- X[,i]
minOrg <- append(minOrg, NA)
maxOrg <- append(maxOrg, NA)
}
else
{
message(paste0("Wartosci niepoprawne w X, kolumna: ", name))
}
}
names(maxOrg) <- nazwa
names(minOrg) <- nazwa
attr(X_norm, 'minOrg') <- minOrg
attr(X_norm, 'maxOrg') <- maxOrg
attr(X_norm, 'minmaxNew') <- minmaxNew
knn <- list()
knn[["X"]] <- X_norm
knn[["y"]] <- y_tar
knn[["k"]] <- k
}
return(knn)
}
}
# - test 1
fac1 <- (sample(1:5, 10, replace = TRUE))
fac2 <- as.factor(sample(2:4, 10, replace = TRUE))
X1 <- cbind(fac1,fac2)
X1 <- as.matrix(X1)
X2 <- data.frame(fac1, fac2)
y_tar <- sample(0:1, 10, replace = TRUE)
k = 2
XminNew <- 0
XmaxNew <- 1
tabelka1 <- KNNtrain(X1, y_tar, k, XminNew, XmaxNew)
tabelka2 <- KNNtrain(X2, y_tar, k, XminNew, XmaxNew)
View(tabelka1)
tabelka1[["X"]][["fac1"]]
fac1 <- (sample(1:10, 10, replace = TRUE))
fac2 <- as.factor(sample(2:4, 10, replace = TRUE))
X1 <- cbind(fac1,fac2)
X1 <- as.matrix(X1)
X2 <- data.frame(fac1, fac2)
y_tar <- sample(0:1, 10, replace = TRUE)
k = 2
XminNew <- 0
XmaxNew <- 1
tabelka1 <- KNNtrain(X1, y_tar, k, XminNew, XmaxNew)
tabelka2 <- KNNtrain(X2, y_tar, k, XminNew, XmaxNew)
tabelka1
tabelka2
KNNtrain <- function(X, y_tar, k, XminNew, XmaxNew) {
if (any(is.na(X) == TRUE || is.na(y_tar) == TRUE)) {
stop("Niekompletne dane!")
}
else if(k <= 0)
{
stop("Za male k")
}
else if(XminNew == XmaxNew)
{
stop("Nowe granice sa takie same!")
}
else if((is.matrix(X) == FALSE & is.data.frame(X) == FALSE))
{
stop("Dane nie sa macierza lub ramka danych!")
}
else{
{
X <- data.frame(X)
X_norm <- data.frame(X)
X_norm[,] <- 0
# Sprawdzic KOD z Projekt_R_knn_Tree_SVM -> funkcje.R
nazwa <- vector()
minOrg <- vector()
maxOrg <- vector()
minmaxNew <- c(XminNew, XmaxNew)
column_names <- colnames(X)
for(i in 1:ncol(X))
{
message(typeof(X[,i]))
if (is.numeric(X[,i]) | is.double(X[,i]) | is.integer(X[,i]))
{
nazwa <- append(nazwa, i)
minOrg <- append(minOrg, min(X[,i]))
maxOrg <- append(maxOrg, max(X[,i]))
X_norm[,i] <- ((X[,i] - min(X[,i])) / (max(X[,i]) - min(X[,i]))) * (XmaxNew - XminNew) + XminNew
}
else if(is.factor(X[,i]) & is.ordered(X[,i]) | is.factor(X[,i]))
{
X_norm[,i] <- X[,i]
minOrg <- append(minOrg, NA)
maxOrg <- append(maxOrg, NA)
}
else
{
message(paste0("Wartosci niepoprawne w X, kolumna: ", name))
}
}
names(maxOrg) <- nazwa
names(minOrg) <- nazwa
attr(X_norm, 'minOrg') <- minOrg
attr(X_norm, 'maxOrg') <- maxOrg
attr(X_norm, 'minmaxNew') <- minmaxNew
knn <- list()
knn[["X"]] <- X_norm
knn[["y"]] <- y_tar
knn[["k"]] <- k
}
return(knn)
}
}
# - test 1
fac1 <- (sample(1:10, 10, replace = TRUE))
fac2 <- as.factor(sample(2:4, 10, replace = TRUE))
X1 <- cbind(fac1,fac2)
X1 <- as.matrix(X1)
X2 <- data.frame(fac1, fac2)
y_tar <- sample(0:1, 10, replace = TRUE)
k = 2
XminNew <- 0
XmaxNew <- 1
tabelka1 <- KNNtrain(X1, y_tar, k, XminNew, XmaxNew)
tabelka2 <- KNNtrain(X2, y_tar, k, XminNew, XmaxNew)
tabelka1
tabelka2
KNNtrain <- function(X, y_tar, k, XminNew, XmaxNew) {
if (any(is.na(X) == TRUE || is.na(y_tar) == TRUE)) {
stop("Niekompletne dane!")
}
else if(k <= 0)
{
stop("Za male k")
}
else if(XminNew == XmaxNew)
{
stop("Nowe granice sa takie same!")
}
else if((is.matrix(X) == FALSE & is.data.frame(X) == FALSE))
{
stop("Dane nie sa macierza lub ramka danych!")
}
else{
{
X <- data.frame(X)
X_norm <- data.frame(X)
X_norm[,] <- 0
# Sprawdzic KOD z Projekt_R_knn_Tree_SVM -> funkcje.R
nazwa <- vector()
minOrg <- vector()
maxOrg <- vector()
minmaxNew <- c(XminNew, XmaxNew)
column_names <- colnames(X)
for(i in 1:ncol(X))
{
#message(typeof(X[,i]))
if (is.numeric(X[,i]))
{
nazwa <- append(nazwa, i)
minOrg <- append(minOrg, min(X[,i]))
maxOrg <- append(maxOrg, max(X[,i]))
X_norm[,i] <- ((X[,i] - min(X[,i])) / (max(X[,i]) - min(X[,i]))) * (XmaxNew - XminNew) + XminNew
}
else if(is.factor(X[,i]) & is.ordered(X[,i]) | is.factor(X[,i]))
{
X_norm[,i] <- X[,i]
minOrg <- append(minOrg, NA)
maxOrg <- append(maxOrg, NA)
}
else
{
message(paste0("Wartosci niepoprawne w X, kolumna: ", name))
}
}
names(maxOrg) <- nazwa
names(minOrg) <- nazwa
attr(X_norm, 'minOrg') <- minOrg
attr(X_norm, 'maxOrg') <- maxOrg
attr(X_norm, 'minmaxNew') <- minmaxNew
knn <- list()
knn[["X"]] <- X_norm
knn[["y"]] <- y_tar
knn[["k"]] <- k
}
return(knn)
}
}
# - test 1
fac1 <- (sample(1:10, 10, replace = TRUE))
fac2 <- as.factor(sample(2:4, 10, replace = TRUE))
X1 <- cbind(fac1,fac2)
X1 <- as.matrix(X1)
X2 <- data.frame(fac1, fac2)
y_tar <- sample(0:1, 10, replace = TRUE)
k = 2
XminNew <- 0
XmaxNew <- 1
tabelka1 <- KNNtrain(X1, y_tar, k, XminNew, XmaxNew)
tabelka2 <- KNNtrain(X2, y_tar, k, XminNew, XmaxNew)
tabelka1
tabelka2
KNNtrain <- function(X, y_tar, k, XminNew, XmaxNew) {
if (any(is.na(X) == TRUE || is.na(y_tar) == TRUE)) {
stop("Niekompletne dane!")
}
else if(k <= 0)
{
stop("Za male k")
}
else if(XminNew == XmaxNew)
{
stop("Nowe granice sa takie same!")
}
else if((is.matrix(X) == FALSE & is.data.frame(X) == FALSE))
{
stop("Dane nie sa macierza lub ramka danych!")
}
else{
{
X <- data.frame(X)
X_norm <- data.frame(X)
X_norm[,] <- 0
# Sprawdzic KOD z Projekt_R_knn_Tree_SVM -> funkcje.R
nazwa <- vector()
minOrg <- vector()
maxOrg <- vector()
minmaxNew <- c(XminNew, XmaxNew)
column_names <- colnames(X)
for(i in 1:ncol(X))
{
#message(typeof(X[,i]))
if (is.numeric(X[,i]))
{
nazwa <- append(nazwa, i)
minOrg <- append(minOrg, min(X[,i]))
maxOrg <- append(maxOrg, max(X[,i]))
X_norm[,i] <- ((X[,i] - min(X[,i])) / (max(X[,i]) - min(X[,i]))) * (XmaxNew - XminNew) + XminNew
}
else if(is.factor(X[,i]) & is.ordered(X[,i]) | is.factor(X[,i]))
{
X_norm[,i] <- X[,i]
minOrg <- append(minOrg, NA)
maxOrg <- append(maxOrg, NA)
}
else
{
message(paste0("Wartosci niepoprawne w X, kolumna: ", name))
}
}
names(maxOrg) <- nazwa
names(minOrg) <- nazwa
attr(X_norm, 'minOrg') <- minOrg
attr(X_norm, 'maxOrg') <- maxOrg
attr(X_norm, 'minmaxNew') <- minmaxNew
knn <- list()
knn[["X"]] <- X_norm
knn[["y"]] <- y_tar
knn[["k"]] <- k
}
return(knn)
}
}
# - test 1
fac1 <- (sample(1:10, 10, replace = TRUE))
fac2 <- as.factor(sample(1:4, 10, replace = TRUE))
X1 <- cbind(fac1,fac2)
X1 <- as.matrix(X1)
X2 <- data.frame(fac1, fac2)
y_tar <- sample(0:1, 10, replace = TRUE)
k = 2
XminNew <- 0
XmaxNew <- 1
tabelka1 <- KNNtrain(X1, y_tar, k, XminNew, XmaxNew)
tabelka2 <- KNNtrain(X2, y_tar, k, XminNew, XmaxNew)
tabelka1
tabelka2
tabelka2$X$fac1
tabelka2$X$fac1$minOrg
attributes(tabelka2$X$fac1)
attributes(tabelka2$X)
KNNtrain <- function(X, y_tar, k, XminNew, XmaxNew) {
if (any(is.na(X) == TRUE || is.na(y_tar) == TRUE)) {
stop("Niekompletne dane!")
}
else if(k <= 0)
{
stop("Za male k")
}
else if(XminNew == XmaxNew)
{
stop("Nowe granice sa takie same!")
}
else if((is.matrix(X) == FALSE & is.data.frame(X) == FALSE))
{
stop("Dane nie sa macierza lub ramka danych!")
}
else{
{
X <- data.frame(X)
X_norm <- data.frame(X)
X_norm[,] <- 0
# Sprawdzic KOD z Projekt_R_knn_Tree_SVM -> funkcje.R
nazwa <- vector()
minOrg <- vector()
maxOrg <- vector()
minmaxNew <- c(XminNew, XmaxNew)
column_names <- colnames(X)
for(i in 1:ncol(X))
{
#message(typeof(X[,i]))
nazwa <- append(nazwa, i)
if (is.numeric(X[,i]))
{
minOrg <- append(minOrg, min(X[,i]))
maxOrg <- append(maxOrg, max(X[,i]))
X_norm[,i] <- ((X[,i] - min(X[,i])) / (max(X[,i]) - min(X[,i]))) * (XmaxNew - XminNew) + XminNew
}
else if(is.factor(X[,i]) & is.ordered(X[,i]) | is.factor(X[,i]))
{
X_norm[,i] <- X[,i]
minOrg <- append(minOrg, NA)
maxOrg <- append(maxOrg, NA)
}
else
{
message(paste0("Wartosci niepoprawne w X, kolumna: ", name))
}
}
names(maxOrg) <- nazwa
names(minOrg) <- nazwa
attr(X_norm, 'minOrg') <- minOrg
attr(X_norm, 'maxOrg') <- maxOrg
attr(X_norm, 'minmaxNew') <- minmaxNew
knn <- list()
knn[["X"]] <- X_norm
knn[["y"]] <- y_tar
knn[["k"]] <- k
}
return(knn)
}
}
# - test 1
fac1 <- (sample(1:10, 10, replace = TRUE))
fac2 <- as.factor(sample(1:4, 10, replace = TRUE))
X1 <- cbind(fac1,fac2)
X1 <- as.matrix(X1)
X2 <- data.frame(fac1, fac2)
y_tar <- sample(0:1, 10, replace = TRUE)
k = 2
XminNew <- 0
XmaxNew <- 1
tabelka1 <- KNNtrain(X1, y_tar, k, XminNew, XmaxNew)
tabelka2 <- KNNtrain(X2, y_tar, k, XminNew, XmaxNew)
tabelka1
tabelka2
attributes(tabelka1$X)
attributes(tabelka2$X)
attributes(tabelka1$X)$minOrg
is.na(tabelka1)
KNNtrain <- function(X, y_tar, k, XminNew, XmaxNew)
{
if (any(is.na(X) == TRUE || is.na(y_tar) == TRUE))
{
stop("Niekompletne dane!")
}
else if(k <= 0)
{
stop("Za male k")
}
else if(XminNew == XmaxNew)
{
stop("Nowe granice sa takie same!")
}
else if((is.matrix(X) == FALSE & is.data.frame(X) == FALSE))
{
stop("Dane nie sa macierza lub ramka danych!")
}
else
{
X <- data.frame(X)
X_norm <- data.frame(X)
X_norm[,] <- 0
nazwa <- vector()
minOrg <- vector()
maxOrg <- vector()
minmaxNew <- c(XminNew, XmaxNew)
column_names <- colnames(X)
for(i in 1:ncol(X))
{
#message(typeof(X[,i]))
nazwa <- append(nazwa, i)
if (is.numeric(X[,i]))
{
minOrg <- append(minOrg, min(X[,i]))
maxOrg <- append(maxOrg, max(X[,i]))
X_norm[,i] <- ((X[,i] - min(X[,i])) / (max(X[,i]) - min(X[,i]))) * (XmaxNew - XminNew) + XminNew
}
else if(is.factor(X[,i]) & is.ordered(X[,i]) | is.factor(X[,i]))
{
X_norm[,i] <- X[,i]
minOrg <- append(minOrg, NA)
maxOrg <- append(maxOrg, NA)
}
else
{
message(paste0("Wartosci niepoprawne w X, kolumna: ", name))
}
}
names(maxOrg) <- nazwa
names(minOrg) <- nazwa
attr(X_norm, 'minOrg') <- minOrg
attr(X_norm, 'maxOrg') <- maxOrg
attr(X_norm, 'minmaxNew') <- minmaxNew
knn <- list()
knn[["X"]] <- X_norm
knn[["y"]] <- y_tar
knn[["k"]] <- k
}
return(knn)
}
# --- test 1
fac1 <- (sample(1:10, 10, replace = TRUE))
fac2 <- as.factor(sample(1:4, 10, replace = TRUE))
X1 <- cbind(fac1,fac2)
X1 <- as.matrix(X1)
X2 <- data.frame(fac1, fac2)
y_tar <- sample(0:1, 10, replace = TRUE)
k = 2
XminNew <- 0
XmaxNew <- 1
tabelka1 <- KNNtrain(X1, y_tar, k, XminNew, XmaxNew)
tabelka2 <- KNNtrain(X2, y_tar, k, XminNew, XmaxNew)
tabelka1
tabelka2
attributes(tabelka1$X)
attributes(tabelka2$X)
View(X1)

# Regresja
y_tar <- rnorm(10)
y_hat <- y_tar + 0.1

MAE <- function( y_tar, y_hat ){
  return( mean( abs(y_tar - y_hat) ) )
}
MAE( y_tar, y_tar )
MAE( y_tar, y_hat )

# Klasyfikacja
y_tar <- c(1,1,0,1,0,1,0,0,0,0)
y_hat <- (length(y_tar):1) / length(y_tar)

table( y_tar, y_tar )
Mat <- table( y_tar, y_hat = ifelse( y_hat <= 0.5, 0, 1 ) )
Mat
sum( diag( Mat ) ) / sum(Mat)

install.packages("pROC")
library("pROC")

plot( roc( y_tar, y_hat ) )
auc_pakiet <- auc( roc( y_tar, y_hat ) )
auc_pakiet

# https://blog.revolutionanalytics.com/2017/03/auc-meets-u-stat.html

auc_Uwmw <- function( y_tar, y_hat ){
  
  y_logic <- as.logical( y_tar ) 
  n2 <- sum(y_logic)
  n1 <- sum(!y_logic)
    
  R2 <- sum( rank( y_hat )[y_logic] )
  licznik <- R2 - n2*(n2+1)/2
  mianownik <- n2 * n1
  
  return( licznik / mianownik )
  
}
auc_Uwmw( y_tar, y_hat )

# Sprawdzian krzyÅ¼owy
kFold <- 10
set.seed(666)
# 1:nrow(dane)

indxT <- sample( x = 1:length(y_tar), size = (1-1/kFold) * length(y_tar), replace = F )
indV <- (1:length(y_tar))[-indxT]

# Tunowanie parametrÃ³w
parTune <- expand.grid( k = 1:5 )
parTune <- expand.grid( kFold = 1:3, k = 1:5 )
parTune

wyniki <- data.frame( parTune, MAEt = 0, MAEv = 0 )
wyniki


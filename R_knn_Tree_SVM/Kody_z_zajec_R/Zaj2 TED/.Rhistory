# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(data=1:1000,nrow=100,ncol=1001)
# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(data=1:1001,nrow=100,ncol=1001)
B
# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(data=1:1001,nrow=1000,ncol=1001)
B
# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(data=c(1:1001),nrow=1000,ncol=1001)
B
# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(data=1,nrow=1000,ncol=1001)
B
lista <- list(for (i in 1000) {lista <- c("x_%"+i) })
for (i in 1000) {lista <- c("x_%"+i)}
for (i in 1000) {lista <- c('x_'i)}
for (i in 1000) {lista <- c("x_"i)}
for (i in 1000) {lista <- c("x_")}
lista
for (i in 1000) {lista[i] <- c("x_")}
for (i in 1000) {
c((paste("x_",i), sep=""))
}
y<-(paste("x_",i), sep="")
y<-paste("x_",i)
for (i in 1000) {
y<-paste("x_",i)
}
y
y[i]<-paste("x_",i)
wektor <- for (i in 1000) {
paste("x_",i)
}
paste("x_",1:1000)
dimnames(B) <- c("Y",paste("x_",1:1000))
lista <- as.list(paste("x_",1:1000))
dimnames(B) <- c("Y",lista)
View(lista)
View(lista)
provideDimnames(B, sep = "", base = list(lista), unique = TRUE)
View(lista)
View(lista)
dimnames(B) <- c("Y",lista)
# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(data=1,nrow=1000,ncol=1001)
B
dimnames(B) <- c("Y",lista)
# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(data=1,nrow=1001,ncol=1000)
B
dimnames(B) <- c("Y",lista)
lista <- as.list(paste("x_",1:1000))
provideDimnames(B, sep = "", base = list(lista), unique = TRUE)
lista
colnames(B) <- c("Y",lista)
lista <- as.list(paste("x_",1:1000))
colnames(B) <- c("Y",lista)
colnames(B) <- c("Y",as.list(paste("x_",1:1000)))
colnames(B) <- c("Y",lista)
x <- matrix(1,3,4)
x
B
colnames(x) <- c("Y","x_1","x_2","x_3")
x
lista <- as.list(paste("x_",1:4))
colnames(x) <- c("Y",lista)
colnames(x) <- bind("Y",lista)
colnames(x) <- ("Y",lista)
colnames(x) <- apply("Y",lista)
colnames(x) <- c("Y",lista)
lista
# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(1,1000,1001)
B
View(B)
View(B)
dim(B)
B
colnames(B) <- paste0(2:ncol(B))
colnames(x) <- c("Y",lista(x))
lista <- as.list(paste("x_",1:4))
colnames(x) <- c("Y",lista(x))
colnames(x) <- c("Y",lista[x])
colnames(B)
lista <- as.list(paste("x_",1:1000))
colnames(B) <- cbind("Y",lista)
colnames(B) <- cbind(lista)
colnames(B) <- cbind()
B
colnames(B) <- c("Y")
B[1]
colnames(B[1]) <- c("Y")
a <- matrix(1,2,4)
a
a <- matrix(c(1,2,3,4,5,6),2,4)
a
a <- matrix(c(1,2,3,4,5,6,7,8),2,4)
a
a[1] <- "Y"
a
dim(a)
a <- matrix(c(1,2,3,4,5,6,7,8),2,4)
colnames(a,1) <- "Y"
colnames(a(1)) <- "Y"
colnames(a) <- c("Y")
colnames(B) <- paste("x",1:1000,sep = "_")
# Zadanie 0:
# a) Stwórz macierz rozmiaru "1000x1001".
#    Przypisz nazwę "Y" do pierwszej kolumny. Przypisz nazwy od "x_1" do "x_1000" do następnych kolumn.
# b) Wstaw losowe wartości z wektora od 1 do 100 w kolumnę "Y". set.seed = (555).
# c) Wstaw do kolumn od "x_1" do "x_1000" wartości zgodne z nastepujacym schematem
#    "x_i = Y + wartość losowa z rozkładu normalnego". set.seed = (555).
B <- matrix(1,1000,1001)
dim(B)
colnames(B) <- c("Y",paste("x",1:1000,sep = "_"))
View(B)
View(B)
set.seed(555)
B[,"Y"]<- sample(x = 1:100,size = 1000,replace = T)
for(i in 2:1001){
B[,i] <-   B[,"Y"]+rnorm(1)
}
B
View(B)
View(B)
model <- paste("Y ~", XnazwyList[[i]][1])
ModelParallel <-
function(dane, Ynazwa, XnazwyList, Nrdzeni, metoda) {
lista_wynik <- list()
dane = data.frame(dane)
if (metoda == 'for') {
wynik <-
foreach(i = 1:length(XnazwyList),
.export = c("lista_wynik")) %dopar% {
model <- paste("Y ~", XnazwyList[[i]][1])
j = 1
while (j < length(XnazwyList[[i]])) {
model <- paste(model, "+", XnazwyList[[i]][j + 1])
j = j + 1
}
model_wyn <- lm(model, data = dane)
lista_wynik[[i]] = cbind(names(coef(model_wyn)), coef(model_wyn))
}
wynik
}
if (metoda == 'lapply') {
parLapply(klaster, 1:Nrdzeni, function() {
model <- lm(dane[, Ynazwa] ~ dane[, XnazwyList[klaster]])
tabela <- cbind(names(coef(model)), coef(model))
lista_wynik[klaster] <- tabela
})
lista_wynik
}
}
ModelParallel(macierz, 'Y', list(x_1, c(x_1, x_5, x_7), x_2, x_3), 4, 'for')
return(mean(abs(a - b)))
MAE <- function(a, b){
return(mean(abs(a - b)))
}
MSE <- function(a, b){
return(mean((a - b)^2))
}
MAPE <- function(a, b){
return(mean(abs((a - b)/a) ))
}
AUC <- function(a, b){
roc_krzywa <- roc(a, b)
TPR <- rev(roc_krzywa$sensitivities)
FPR <- rev(1 - roc_krzywa$specificities)
dFPR <- c(diff(FPR), 0)
dTPR <- c(diff(TPR), 0)
AUC_wynik <- sum(TPR * dFPR) + sum(dTPR * dFPR)/2
return(AUC_wynik)
}
Youden <- function(a, b){
roc_krzywa <- roc(a, b)
TPR <- roc_krzywa$sensitivities
FPR <- roc_krzywa$specificities
max_Y <- 0
for (i in 1:length(TPR)) {
Youden <- (TPR[i] + FPR[i]-1)
if(Youden > max_Y){
max_Y=Youden
}
}
return(max_Y)
}
Mat <- table(y_tar, y_hat = ifelse(y_hat <= Youden(y_tar, y_hat), 0, 1))
Youden <- function(y_tar, y_hat){
roc_obj <- roc(y_tar, y_hat)
TPR <- roc_obj$sensitivities #czu?o??
FPR <- roc_obj$specificities #specyficzno??
max_J <- 0
for (i in 1:length(TPR)) {
J <- (TPR[i] + FPR[i]-1)
if(J > max_J){
max_J=J
}
}
return(max_J)
}
Mat <- table(y_tar, y_hat = ifelse(y_hat <= Youden(y_tar, y_hat), 0, 1))
Czulosc <- function(Mat){
return((Mat[1] / (Mat[1] + Mat[3])))
}
Specyficznosc <- function(Mat){
return((Mat[4] / (Mat[4] + Mat[2])))
}
Jakosc <- function(Mat){
return(((Mat[1] + Mat[4]) / (Mat[1] + Mat[2] + Mat[3] + Mat[4])))
}
ModelOcena <- function(y_tar, y_hat){
if(is.numeric(y_tar)){
regresja <- c("MAE" = MAE(y_tar, y_hat), "MSE" = MSE(y_tar, y_hat), "MAPE" = MAPE(y_tar, y_hat))
return(regresja)
}
else if(is.factor(y_tar)){
miary <- c( "AUC" = AUC(y_tar, y_hat), "Czulosc" = Czulosc(Mat), "Specyficznosc" = Specyficznosc(Mat), "Jakosc" = Jakosc(Mat))
klasyfikacja <- list(Mat, Youden(y_tar, y_hat), miary)
return(klasyfikacja)
}
else{
c("Dane niepoprawne")
}
}
#Regresja
y_tar <- rnorm(20)
y_hat <- y_tar + 0.3
ModelOcena(y_tar,y_hat)
#Klasyfikacja
y_tar <- c(0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,0)
y_hat <- (length(y_tar):1) / length(y_tar)
y_tar<-as.factor(c(y_tar))
ModelOcena(y_tar,y_hat)
CrossValidTune <- function(dane, kFold, parTune, seed){
set.seed(seed)
k = nrow(dane)
wektor = c()
lista = list()
for (j in 1:kFold){
indxT <- sample( x = 1:k, size = round((1-1/kFold) * k), replace = F )
s_indxT = sort(indxT)
p <- 1
while (p<=length(s_indxT)){
for (i in 1:k){
if (s_indxT[p] == i){
wektor[i] == 1
p = p+1
}
else{
wektor[i] == 2
}
}
}
lista[[j]] = c(wektor)
}
ramka_r <- data.frame( kFold_par =c(1,2,1,2))
for (i in 1:(length(parTune))){
ramka_r[i+1] = parTune[i]
}
if(is.numeric(y_tar)){
f_reg <- ramka_r
f_reg['MAEt'] = 0
f_reg['MSEt'] = 0
f_reg['MAPEt'] = 0
f_reg['MAEw'] = 0
f_reg['MSEw'] = 0
f_reg['MAPEw'] = 0
return(f_reg)
}
else if(is.factor(y_tar)){
f_klas <- ramka_r
f_klas['AUCT'] = 0
f_klas['Czulosc'] = 0
f_klas['Specyficznosc'] = 0
f_klas['Jakosc?'] = 0
f_klas['AUCW'] = 0
f_klas['Specyficznosc'] = 0
f_klas['MAPEW'] = 0
f_klas['Jakosc'] = 0
return(f_klas)
}
}
CrossValidTune(data.frame(c(1:10),c(3:12)), 5, data.frame( a = c(1,2), b = c(1,1) ), 555)
